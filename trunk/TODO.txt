// TODO investigate PyArray_Where

/*
 * NumPy's get algorithm:
 * <CODE>
 * if (op is integer) {
 *     array_item_nice:
 *     if (nd == 1) {
 *         return array scalar using index2ptr
 *     } else {
 *         use index2ptr to get get pointer to data
 *         returned array has nd - 1; first dimension and stride are stripped off
 *         return array_big_item(i) through PyArray_Return
 *     }
 * }
 * if (op is tuple with exactly nd elements) {
 *     return array scalar using PyArray_GetPtr to get value
 * }
 *
 * else: call array_subscript with op, which does:
 *     if (PyString_Check(op) || PyUnicode_Check(op)) {
 *         look for a field named op
 *     }
 *     if nd == 0 {
 *         if op == ellipsis
 *             return self (for array scalars)
 *         if op == None
 *             return self with a new axis
 *         if op is a tuple
 *             if tuple is empty
 *                 return self
 *             if ((nd = count_new_axes_0d(op)) == -1)
 *                 return NULL;
 *             return add_new_axes_0d(self, nd);
 *     }
 *     check if op implies fancy indexing
 *     if (op is fancy) {
 *         ...
 *     }
 *     else: call array_subscript_simple, which does:
 *         if (op can be converted to intp) {
 *             return array_big_item(op as intp)
 *         }
 *         // this can return an error
 *         calculate nd = parse_index(self, op, dimensions, strides, &offset)
 *         parse_index does:
 *             if op is slice, ellipsis or None:
 *                 incref op
 *                 set n = 1
 *                 set is_slice to 1
 *             else:
 *                 if op is not a sequence, throw
 *                 n = sequence length of op
 *                 is_slice = 0
 *             for (int i : 0 -> i < n)
 *                 if (!is_slice)
 *                     check that i is a valid index into op (which is a known to be a sequence)
 *                 start = parse_subindex(op1, &step_size, &n_steps, XXX conditional)
 *                 if start == -1: break
 *                 XXX big conditional
 *             XXX another conditional
 *
 *
 *
 *         return array with new nd, same dimensions, same strides, data pointer at: data+offset
 *
 * if array_subscript returned array with nd == 0:
 *     do various checks related to op being an ellipsis
 *     return an array scalar in some cases
 *
 * </CODE>
 */
 